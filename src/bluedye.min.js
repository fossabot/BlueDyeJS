/**
 * BlueDyeJS v2.0.0
 * by Yazid SLILA (@yokgs)
 * MIT License
 */
!function (r, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : r.bluedye = e() }(this, (function () { "use strict"; var rgb = (r, g, b) => [r, g, b, 1], rgba = (r, g, b, a) => [r, g, b, a], Hex = a => (a > 15 ? "" : "0") + Math.floor(a).toString(16), fromHex = a => 4 == a.length ? parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16) : parseInt(a.substr(1), 16), correction = a => Math.max(0, Math.min(Math.round(a), 255)), alpha_correction = a => Math.max(0, Math.min(a, 1)), _dark = (a, b) => (1 - b / 100) * a, _light = (a, b) => a + b / 100 * (255 - a), bluedye = function (color) { return new localBlueDye.color(color) }; let localBlueDye = bluedye.prototype = { color: function (color) { var s = [0, 0, 0]; if (void 0 === color && (s[3] = 0), "string" == typeof color) if (/^#[0-1a-fA-F]+/.test(color)) color = fromHex(color); else { if (color in _private.colors) return bluedye(_private.colors[color]); if (/^rgba*\([\d,\.\s]+\)/.test(color)) { let rgb = (r, g, b) => [r, g, b, 1], rgba = (r, g, b, a) => [r, g, b, a]; try { s = eval(color) } catch (_) { } } } return "number" == typeof color ? bluedye.number(color) : "object" == typeof color && color.length && (s = color, 1 === s.length) ? bluedye.grayscale(s[0]) : ("boolean" == typeof color && (s = color ? [255, 255, 255, 1] : [0, 0, 0, 1]), this.RED = correction(s[0]), this.GREEN = correction(s[1]), this.BLUE = correction(s[2]), this.ALPHA = alpha_correction("number" != typeof s[3] ? 1 : s[3]), this.R = this.toArray(), this.backup = [], this.tag = null, this.save()) }, save: function () { return this.backup.push({ r: this.RED, g: this.GREEN, b: this.BLUE, a: this.ALPHA }), this }, undo: function () { this.backup.pop(); var i = this.backup.pop(); return [this.RED, this.GREEN, this.BLUE, this.ALPHA] = [i.r, i.g, i.b, i.a], this.save() }, pin: function () { return this.R = this.toArray(), this.backup = [], this.save() }, reset: function () { return [this.RED, this.GREEN, this.BLUE, this.ALPHA] = this.R, this.backup = [], this.save() }, red: function (red) { return "number" == typeof red && (this.RED = correction(red)), this.save() }, green: function (green) { return "number" == typeof green && (this.GREEN = correction(green)), this.save() }, blue: function (blue) { return "number" == typeof blue && (this.BLUE = correction(blue)), this.save() }, alpha: function (alpha) { return this.ALPHA = alpha_correction(alpha), this.save() }, rgb: function (r, g, b) { return [this.RED, this.GREEN, this.BLUE] = [r, g, b].map(correction), this.save() }, rgba: function (r, g, b, a) { return [this.RED, this.GREEN, this.BLUE] = [r, g, b].map(correction), this.ALPHA = alpha_correction(a), this.save() }, dark: function (level = 1) { return level = Math.min(Math.max(level, 0), 100), [this.RED, this.GREEN, this.BLUE] = this.toArray().map(x => _dark(x, level)), this.save() }, light: function (level = 1) { return level = Math.min(Math.max(level, 0), 100), [this.RED, this.GREEN, this.BLUE] = this.toArray().map(x => _light(x, level)), this.save() }, negative: function () { return [this.RED, this.GREEN, this.BLUE] = this.toArray().map(x => 255 - x), this.save() }, redToBlue: function () { return [this.BLUE, this.RED, this.GREEN] = this.toArray(), this.save() }, blueToRed: function () { return [this.GREEN, this.BLUE, this.RED] = this.toArray(), this.save() }, gray: function () { let y = (this.RED + this.GREEN + this.BLUE) / 3; return this.RED = this.GREEN = this.BLUE = y, this.save() }, grey: function () { return this.gray() }, random: function () { return this.RED = correction(256 * Math.random()), this.GREEN = correction(256 * Math.random()), this.BLUE = correction(256 * Math.random()), this.save() }, css: function () { return 1 === this.ALPHA ? `rgb(${correction(this.RED)},${correction(this.GREEN)},${correction(this.BLUE)})` : `rgba(${correction(this.RED)},${correction(this.GREEN)},${correction(this.BLUE)},${alpha_correction(this.ALPHA)})` }, hex: function () { return `#${Hex(this.RED)}${Hex(this.GREEN)}${Hex(this.BLUE)}` }, number: function () { return 256 * (256 * this.RED + this.GREEN) + this.BLUE }, toArray: function () { return [this.RED, this.GREEN, this.BLUE, this.ALPHA] }, setTag: function (tag) { return this.tag && delete _private.tags[this.tag], _private.tags[tag] = this, this.tag = tag, this }, name: function (name) { return /[\w\-]+/.test(name) && (_private.colors[name] = this.css()), this } }; localBlueDye.color.prototype = localBlueDye, bluedye.add = function (obj, overwrite) { for (let k in obj) { var t; (k in bluedye && overwrite || !(k in bluedye)) && (bluedye[k] = obj[k]) } return bluedye }; let _private = { colors: {}, tags: {} }; return bluedye.add({ version: [2, 0, 0], alpha: !1, getColor: function (tag) { return _private.tags[tag] }, rgb: function (r, g, b) { return bluedye(`rgb(${r},${g},${b})`) }, rgba: function (r, g, b, a) { return bluedye(`rgba(${r},${g},${b},${a})`) }, number: function (n) { var s = [0, 0, 0]; for (let i = 2; i >= 0; i--)s[i] = Math.floor(n) % 256, n /= 256; return bluedye(s) }, colorName: function (name) { return bluedye(_private.colors[name]) }, grayscale: function (a) { return bluedye.rgb(a, a, a) }, random: function () { return bluedye().random() } }, !0), bluedye }));